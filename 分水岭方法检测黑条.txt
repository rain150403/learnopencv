// Use opencv built-in methods to get image filenames of specified folder.

#include <iostream>
//#include <vector>
//#include <string>
using namespace std;

#include <opencv2\opencv.hpp>
#include <opencv2\highgui\highgui.hpp>
#include <opencv2\contrib\contrib.hpp>
#include <windows.h>
#include <opencv2\imgproc\imgproc.hpp>

using namespace cv;

void my_watershed(Mat image);
Vec3b RandomColor(int value);  //生成随机颜色函数 

int ng_num = 0;

int main(int argc, char* argv[])
{
	string dir_path = "D:\\waitDelete\\roiImage\\louxiaxinpai\\黑色胶条\\ok_train_1\\";
	Directory dir;
	vector<string> fileNames = dir.GetListFiles(dir_path, "*.jpg", false);

	for (int i = 0; i < fileNames.size(); i++)
	{
		//get image name
		string fileName = fileNames[i];
		string fileFullName = dir_path + fileName;
		//cout << "File name:" << fileName << endl;
		cout << "Full path:" << fileFullName << endl;

		LARGE_INTEGER nFreq;
		LARGE_INTEGER nBeginTime;
		LARGE_INTEGER nEndTime;
		double dtime;
		QueryPerformanceFrequency(&nFreq);
		QueryPerformanceCounter(&nBeginTime);

		//load image
		Mat srcImg = imread(fileFullName.c_str());
		//imshow("src", srcImg);
		//waitKey(0);
		my_watershed(srcImg);
		
		QueryPerformanceCounter(&nEndTime);
		dtime = (double)(nEndTime.QuadPart - nBeginTime.QuadPart) / (double)nFreq.QuadPart;
		cout << "代码的运行时间为" << dtime << "毫秒!"  << endl;
	}

	cout << "总图片数：" << fileNames.size() << "ng图片数:" << ng_num << endl;

	system("pause");
	return 0;
}

void my_watershed(Mat image){
	//灰度化，滤波，Canny边缘检测  
	Mat imageGray;
	cvtColor(image, imageGray, CV_RGB2GRAY);//灰度转换  
	GaussianBlur(imageGray, imageGray, Size(5, 5), 2);   //高斯滤波  
	//imshow("Gray Image", imageGray);
	Canny(imageGray, imageGray, 30, 50);    //80, 150   ,    (50, 100)的时候还不错， （40， 70）更好
	//imshow("Canny Image", imageGray);
	
	//查找轮廓  
	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;
	findContours(imageGray, contours, hierarchy, RETR_LIST, CHAIN_APPROX_NONE, Point());     ////  RETR_TREE, CHAIN_APPROX_SIMPLE
	Mat imageContours = Mat::zeros(image.size(), CV_8UC1);  //轮廓     
	Mat marks(image.size(), CV_32S);   //Opencv分水岭第二个矩阵参数  
	marks = Scalar::all(0);
	int index = 0;
	int compCount = 0;
	for (; index >= 0; index = hierarchy[index][0], compCount++){
		//对marks进行标记，对不同区域的轮廓进行编号，相当于设置注水点，有多少轮廓，就有多少注水点  
		drawContours(marks, contours, index, Scalar::all(compCount + 1), 1, 8, hierarchy);
		drawContours(imageContours, contours, index, Scalar(255), 1, 8, hierarchy);
	}
	for (size_t i = 0; i< contours.size(); i++){
		cout << " area: " << contourArea(contours[i]) << " length: " << arcLength(contours[i], true) << endl;
	}

	if (contours.size() >= 3){
		cout << "这是一张NG图片！" << endl;
		ng_num++;
	}
	
	//我们来看一下传入的矩阵marks里是什么东西  
	Mat marksShows;
	convertScaleAbs(marks, marksShows);
	//imshow("marksShow", marksShows);
	//imshow("轮廓", imageContours);
	watershed(image, marks);
	
	//我们再来看一下分水岭算法之后的矩阵marks里是什么东西  
	Mat afterWatershed;
	convertScaleAbs(marks, afterWatershed);
	//imshow("After Watershed", afterWatershed);
	
	//对每一个区域进行颜色填充  
	Mat PerspectiveImage = Mat::zeros(image.size(), CV_8UC3);
	for (int i = 0; i<marks.rows; i++){
		for (int j = 0; j<marks.cols; j++){
			int index = marks.at<int>(i, j);
			if (marks.at<int>(i, j) == -1){
				PerspectiveImage.at<Vec3b>(i, j) = Vec3b(255, 255, 255);
			}
			else
			{
				PerspectiveImage.at<Vec3b>(i, j) = RandomColor(index);
			}
		}
	}
	//imshow("After ColorFill", PerspectiveImage);
	//imwrite("321.jpg", PerspectiveImage);
	
	//分割并填充颜色的结果跟原始图像融合  
	Mat wshed;
	addWeighted(image, 0.4, PerspectiveImage, 0.6, 0, wshed);
	//imshow("AddWeighted Image", wshed);
	//imwrite("4321.jpg", wshed);
	
	//waitKey();

	cout << "*************************************************" << endl;
}

Vec3b RandomColor(int value)    //<span style = "line-height: 20.8px; font-family: sans-serif;">//生成随机颜色函数</span>  
{
	value = value % 255;  //生成0~255的随机数  
	RNG rng;
	int aa = rng.uniform(0, value);
	int bb = rng.uniform(0, value);
	int cc = rng.uniform(0, value);
	return Vec3b(aa, bb, cc);
}